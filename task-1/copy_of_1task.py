# -*- coding: utf-8 -*-
"""1task.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14VTcI02D41LhUI6mUxvorgb7xJg52Ezh
"""

import numpy as np
import math
import matplotlib.pyplot as plt
import random
import scipy
from scipy.linalg import solve

"""Нужно сформировать выборку $\{(x^{(i)}, y^{(i)})\}_{i=1}^N.$

`N` -- размер выборки.

`e_0` -- некоторое заданное положительное число (граница ошибки $[-e_0, e_0]$).

[-1, 1] -- интервал, на котором генерируется в соответствии с равномерным распределением аргументы для выборки $x^{(i)}.$
"""

N = 3
e_0 = 0.1

"""В качестве функции выбрана следующая:"""


def f(x):
    return x * np.sin(2 * np.pi * x ** 2) + np.array([np.random.uniform(-e_0, e_0) for _ in range(N)])


"""## Выборка"""

x_values = np.array([np.random.uniform(-1, 1) for _ in range(N)])
y_values = f(x_values)

"""## Истинная функция (без ошибки)"""

step = 0.001
x_function_values = np.arange(-1, 1, step)
y_function_values = np.array(x_function_values * np.sin(2 * np.pi * x_function_values ** 2))

"""## График"""

plt.xlim([-2, 2])
plt.ylim([-4, 4])
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='green', label='Истинная функция')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

"""## Восстановление функциональной зависимости с помощью полиномиальной регрессии"""

M = 7
A = np.zeros(shape=(M, M))
b = np.zeros(shape=(M))


def a_element(i, j):
    sum = 0
    for k in range(N):
        sum += x_values[k] ** (j + i)
    return sum


def b_element(i):
    sum = 0
    for k in range(N):
        sum += y_values[k] * (x_values[k] ** i)
    return sum


"""## Заполняем A и b"""

for i in range(M):
    for j in range(M):
        A[i][j] = a_element(i, j)

for i in range(M):
    b[i] = b_element(i)

"""## Решаем уравнение и получаем вектор коэффициентов"""

w = solve(A, b)


def calc_poly(x):
    sum = 0
    for i in range(M):
        sum += w[i] * x_function_values ** i
    return sum


plt.xlim([-2, 2])
plt.ylim([-4, 4])
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)')
plt.plot(x_function_values, y_function_values, color='red', label='Истинная зависимость')
plt.plot(x_function_values, calc_poly(x_function_values), color='green', label='Полиномиальная регрессия')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

"""## Функция f(x) с нормальным распределением ошибки"""

plt.cla()
N = 4
e_0 = 0.1
M = 4


def f(x):
    return x * np.sin(2 * np.pi * x) + np.array([np.random.normal(0, 1) for _ in range(N)])


x_values = np.array([np.random.uniform(-1, 1) for _ in range(N)])
y_values = f(x_values)
step = (2 / N)
x_function_values = np.arange(-1, 1, step)
y_function_values = np.array(x_function_values * np.sin(2 * np.pi * x_function_values))
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='green', label='Истинная функция')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

A = np.zeros(shape=(M, M))
b = np.zeros(shape=(M))


def a_element(i, j):
    sum = 0
    for k in range(N):
        sum += x_values[k] ** (j + i)
    return sum


def b_element(i):
    sum = 0
    for k in range(N):
        sum += y_values[k] * (x_values[k] ** i)
    return sum


for i in range(M):
    for j in range(M):
        A[i][j] = a_element(i, j)

for i in range(M):
    b[i] = b_element(i)
w = solve(A, b)


def calc_poly(x):
    sum = 0
    for i in range(M):
        sum += w[i] * x_function_values ** i
    return sum


plt.xlim([-2, 2])
plt.ylim([-4, 4])
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='red', label='Истинная зависимость')
plt.plot(x_function_values, calc_poly(x_function_values), color='green', label='Полиномиальная регрессия')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

"""## Другая функция f(x) с равномерным распределением ошибки"""

plt.cla()
N = 4
e_0 = 0
M = 4
a, b, c, d = [random.uniform(-3, 3) for _ in range(4)]


def f(x):
    return a * x ** 3 + b * x ** 2 + c * x + d


x_values = np.array([np.random.uniform(-1, 1) for _ in range(N)])
y_values = f(x_values) + np.array([np.random.uniform(-e_0, e_0) for _ in range(N)])
step = 0.001
x_function_values = np.arange(-1, 1, step)
y_function_values = np.array(f(x_function_values))
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='green', label='Истинная функция')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

A = np.zeros(shape=(M, M))
b = np.zeros(shape=(M))


def a_element(i, j):
    sum = 0
    for k in range(N):
        sum += x_values[k] ** (j + i)
    return sum


def b_element(i):
    sum = 0
    for k in range(N):
        sum += y_values[k] * (x_values[k] ** i)
    return sum


for i in range(M):
    for j in range(M):
        A[i][j] = a_element(i, j)

for i in range(M):
    b[i] = b_element(i)
w = solve(A, b)


def calc_poly(x):
    sum = 0
    for i in range(M):
        sum += w[i] * x_function_values ** i
    return sum


plt.xlim([-2, 2])
plt.ylim([-4, 4])
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='red', label='Истинная зависимость')
plt.plot(x_function_values, calc_poly(x_function_values), color='green', label='Полиномиальная регрессия')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

"""Другая функция f(x) с нормальным распределением ошибки"""

plt.cla()
N = 5000
e_0 = 0.1
M = 20
a, b, c, d = [random.uniform(-3, 3) for _ in range(4)]


def f(x):
    return a * x ** 3 + b * x ** 2 + c * x + d


x_values = np.array([np.random.uniform(-1, 1) for _ in range(N)])
y_values = f(x_values) + np.array([np.random.normal(0, 1) for _ in range(N)])
step = 0.001
x_function_values = np.arange(-1, 1, step)
y_function_values = np.array(f(x_function_values))
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='green', label='Истинная функция')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

A = np.zeros(shape=(M, M))
b = np.zeros(shape=(M))


def a_element(i, j):
    sum = 0
    for k in range(N):
        sum += x_values[k] ** (j + i)
    return sum


def b_element(i):
    sum = 0
    for k in range(N):
        sum += y_values[k] * (x_values[k] ** i)
    return sum


for i in range(M):
    for j in range(M):
        A[i][j] = a_element(i, j)

for i in range(M):
    b[i] = b_element(i)
w = solve(A, b)


def calc_poly(x):
    sum = 0
    for i in range(M):
        sum += w[i] * x_function_values ** i
    return sum


plt.xlim([-2, 2])
plt.ylim([-4, 4])
plt.scatter(x_values, y_values, label='Данные выборки (с ошибкой)', s=1)
plt.plot(x_function_values, y_function_values, color='red', label='Истинная зависимость')
plt.plot(x_function_values, calc_poly(x_function_values), color='green', label='Полиномиальная регрессия')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()
